\documentclass{amsart}
\usepackage{amsmath,amssymb,amsthm,mathrsfs,microtype}
\usepackage{minted}
\usepackage[margin=1in]{geometry}

\newtheorem{theorem}{Theorem}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{lemma}[theorem]{Lemma}

\newcommand{\code}[1]{\mintinline{python}{#1}}

\newcommand{\CC}{\mathbb{C}}
\newcommand{\BB}{\mathbb{B}}
\newcommand{\ot}{\otimes}
\newcommand{\op}{\oplus}
\newcommand{\aaa}{\mathbf{a}}
\newcommand{\bbb}{\mathbf{b}}
\newcommand{\ccc}{\mathbf{c}}
\newcommand{\vvv}{\mathbf{v}}
\newcommand{\www}{\mathbf{w}}

\title{Appendix: Border Apolarity Implementation}

\begin{document}
\maketitle
\section{Introduction}\label{sec:intro}
Given a tensor $T \in A \ot B\ot C$, a natural number $r$, and a reductive group
$G_T \subset \operatorname{GL}(A) \times \operatorname{GL}(B)
\times \operatorname{GL}(C)$ stabilizing $T$, this file implements complete
enumeration of candidate subspaces $F_{110}\subset T(C^*)^\perp \subset A^*\ot
B^*$ which (i) have codimension $r$ in $A^*\ot B^*$, (ii)
are fixed under the Borel $\BB_T$ of $G$, and (iii) which pass the (210) and (120)
tests. That is, for such $F_{110}$, the symmetrization maps
\begin{align}
&\label{f210} F_{110}\ot A^*\to S^2 A^*\ot B^* \text { and}\\
&\label{f120} F_{110}\ot B^*\to A^*\ot S^2 B^*
\end{align}
have image of codimension at least $r$. More precisely, we enumerate
the matrices representing such subspaces $F_{110}$ in fixed bases.
Such candidates may occur in positive dimensional families, so these matrices
may have entries in the coordinate ring of some affine variety.

The same computation with the roles of $A$, $B$, and $C$ permuted may be
performed to enumerate the candidate $F_{101}$ and $F_{011}$ subspaces.
Given a triple of candidates $(F_{110}, F_{101}, F_{011})$, a routine to apply
the (111)-test is provided. That is, the map
\begin{equation}\label{111map}
F_{110}\ot C^*\op F_{101}\ot B^*\op F_{011}\ot A^* \to A^*\ot B^*\ot C^*
\end{equation}
is implemented, and it may be checked if the codimension of its image is at
least $r$.

\subsection{Input description}\label{sec:input}

Choose bases of $A$, $B$ and $C$ consisting of weight vectors under the torus of
$G_T$. The tensor $T$ is described by its coefficients with respect to these
bases. The action of $\BB_T$ is described by the weights of the basis vectors
along with the representations $\mathfrak{n} \to
\mathfrak{gl}(A)$, $\mathfrak{n} \to \mathfrak{gl}(B)$, and $\mathfrak{n} \to
\mathfrak{gl}(C)$. Concretely, Representations of $\mathfrak{n}$ are described
by giving the matrix of the action of the simple root vectors in the
distinguished bases.

The function \code{check_input} takes $T$ and this representation data and
ensures that $T$ is actually fixed by the representation. % move to later

\subsection{Software used}

The code is written in Python 3, using the libraries provided by SageMath.

\subsection{Conventions}

% \begin{center}
% \begin{tabular}{lll}
% Name & Object & Representation \\
% \code{T} & $T$ & the list $[X_i]_i$, where each $X_i\in B\ot C$ is a matrix, 
% $T = \sum_{i=1}^a a_i\ot X_i$ \\
% \code{wt} & weight & tuple of integers \\
% \code{wts} & weights of distinguished basis & List of weights
% \end{tabular}
% \end{center}

\code{T}: The tensor $T$ represented as a list of length $\aaa$ of $\bbb \times
\ccc$ matrices $[X_i]_i$. Here each $X_i$ represents an element of $B\ot C$, and
$T=\sum_i a_i \ot X_i$.

\code{wt}: A weight, represented as a Sage vector of integers.

\code{wts}: A list of weights, e.g., the weights of a the distinguished
base of a vector space.

\code{wtss}: A list of length 3, each element of which is a list of the
weights of the distinguished bases of each of $A$, $B$, and $C$. Each weight is
a vector of integers.


\section{Program Listing}

<<complete=False>>=

from __future__ import print_function
from IPython import embed
from itertools import *

@

Given $T\in A\ot B\ot C$ and the representations of $A$, $B$, and $C$, this
function checks checks the input data for correctness in various ways (see the 
inline notes), and also computes the simple roots implied by the representation data.

<<complete=False>>=
def find_simple_roots(T,reps):
    a = len(T)
    b,c = T[0].dimensions()

    # There is one weight for each basis vector
    assert all(len(wts) == d for d,(wts,_) in zip((a,b,c),reps))
    # The given representations of $\mathfrak{n}$ operate on the correct dimensional space
    assert all(x.nrows() == d and x.ncols() == d 
            for d,(_,xs) in zip((a,b,c),reps) for x in xs)

    # compute roots of the simple roots vectors xs
    simple_roots = []
    for xi in range(len(reps[0][1])):
        for wts,xs in reps:
            if not xs[xi].is_zero():
                i,j = xs[xi].nonzero_positions()[0]
                simple_roots.append(wts[i] - wts[j])
                break

    # Check xs are actally root vectors for the corresponding roots and that 
    # the simple roots agree for each rep in reps
    for wts,xs in reps:
        assert len(simple_roots) == len(xs)
        for root,x in zip(simple_roots,xs):
            for i,j in x.nonzero_positions():
                assert wts[i]-wts[j] == root

    # Check T is weight zero in $A\ot B\ot C$
    for i,m in enumerate(T):
        for j,k in m.nonzero_positions():
            assert (reps[0][0][i] + reps[1][0][j] + reps[2][0][k]).is_zero()

    # TODO check if t is closed under the action of $\mathfrak{n}$

    return simple_roots

@
<<complete=False>>=

# border apolarity specialized to cyclic invariant tensors, so only 110
# candidates are computed. 
def border_apolarity_cycl_inv(T,reps,r):
    simple_roots = find_simple_roots(T,reps)
    reptp,em = Tperp_rep_and_embedding(T,reps)
    wtd = weight_diagram(reptp,simple_roots)

    adim = len(T)
    cand110 = []
    for ghwv in borel_fixed_subspaces(wtd, em.nrows()-r):
        cand = em*ghwv
        cand = AB_grass_restrict_ok(cand,adim,r)
        if cand is not None:
            cand110.append(cand)
            print('candidates',len(cand110))

    # For our purposes, assume that there are no parameters in the results
    # (and there is at most one solution for each choice of charts of the
    # grassmannians). If this condition does not hold, the following will throw
    # an exception
    cand110 = [ cand.change_ring(QQ) for cand in cand110 ]

    cand111 = []
    for xs in product(*map(enumerate,[cand110]*3)):
        ixs = tuple(i for i,x in xs)
        if ixs != min([ixs,ixs[1:]+ixs[:1],ixs[2:]+ixs[:2]]):
            # we may skip triples equal to others we check modulo cyclic permutation
            continue
        print(ixs,end=' ')
        sys.stdout.flush()

        W = matrix_to_111(*[x for _,x in xs])
        if W.rank() <= W.dimensions()[0] - r:
            cand110.append(W)
    return cand111,cand110

@

\subsection {$\BB$-fixed subspace enumeration}

For a module $M$, $\BB$-fixed subspaces are parameterized by a choices of 
subspaces $S_\lambda \subset M_\lambda$ where $x. S_\lambda \subset S_\mu$ for
every raising operator $x$ corresponding to an arrow $M_\lambda \to M_\mu$ in the
weight diagram (see \S2.5.2 of the article). This parameterization is composed
of two components, the combinatorial data $d_\lambda =
\operatorname{dim} S_\lambda$, and the subvariety $Y_{d_\lambda}$ of the product of
Grassmannians $X_{d_\lambda} = \prod_{\lambda} Gr(M_\lambda,d_\lambda)$ corresponding to
the condition on weight diagram arrows above.

For fixed $D$, most assignments $\lambda \mapsto d_\lambda$ satisfying
$\sum_\lambda d_\lambda = D$ have $Y_d = \varnothing$, and to explicitly check
each such $d_\lambda$ would be impossible. Hence, we investigate only such assignments
$d_\lambda$ satisfying necessary conditions for $Y_d\ne \varnothing$. These conditions
take the form of linear inequalities. Thus, the assignments
we explicitly consider occur as the set of integer points of a
polytope, which can be efficiently enumerated.


% We may parameterize the $\fb_T$ fixed subspaces $M$ of dimension $d$ as follows: Fix an assignment of dimensions $d_\lambda$, $0\le d_\lambda \le \tdim M_\lambda$,
% $\sum_\lambda d_\lambda = d$. Choices of $S_\lambda$ with $\dim S_\lambda = d_\lambda$ are
% parameterized by the product of Grassmannians $X = \prod_{\lambda} G(M_\lambda,d_\lambda)$.
% Given a raising operator $x$ corresponding to an arrow $M_\lambda \to M_\mu$ in the
% weight diagram, the condition that $x. S_\lambda
% \subset S_{\mu}$ is an explicit polynomial condition on $X$. Cutting
% $X$ by all such polynomials gives a description of the set of $\fb_T$ fixed
% subspaces with $\dim S_\lambda = d_\lambda$ (which can be empty). All Borel fixed
% subspaces are obtained as $d_\lambda$ ranges over all such assignments.
% In small examples, a complete list of $\fb_T$ fixed subspaces may frequently be
% read off of the weight diagram.

This function returns a generator yielding the set of highest weight vectors 
of the grassmannian, each possibly parameterized (having entries in a
polynomial ring modulo an ideal). The grassmannian planes are represented 
as the column space of matrices.
<<complete=False>>=
# mdata is the information for the module as summarized by weight_decomposition
# subdim determines which grassmannian to consider (the dimension of the returned spaces)
def borel_fixed_subspaces(wtd,D,verbose=True):
    for i,dlambda in enumerate(possible_dim_assignments(wtd,D)):
        if verbose:
            print(i,end=' ')
        for S in borel_fixed_subspaces_dlambda(wtd,dlambda,verbose):
            yield S

@
Given a weight diagram and an assignment $\lambda \mapsto d_\lambda$, this
function enumerates corresponding matrices corresponding to $Y_{d_\lambda}$.

A Grassmannian $Gr(V,s)$ may be represented in bases as $s\times \vvv$ matrix
modulo the left action of $\operatorname{GL}(s)$. A normal form for this
action is ordinary echelon form of the matrix, so $Gr(V,s)$ may be written as a
disjoint union of affine spaces according to the pivot columns of echelon forms.

Thus, the set $X_{d_\lambda}$ is parameterized by combinations of such choices
of pivot columns in each weight space. This function looks at each of these and
computes the variety corresponding to the intersection with $Y_{d_\lambda}$. 
A list of matrices with entries in the coordinate ring modulo these
$Y_{d_\lambda}$ equations is returned.

<<complete=False>>=

def borel_fixed_subspaces_dlambda(wtd,dlambda,verbose=False):

    dlist = [(wt,d,len(wtd.get_vertex(wt))) for wt, d in dlambda.items()]

    if verbose: 
        missing = [wt for wt,d in dlambda.items() if d < len(wtd.get_vertex(wt))]
        missing.sort(key=lambda wt: (sum(wt),wt))
        print('grass hwv missing',missing)


    if all(m == f or m == 0 for wt,m,f in dlist):
        # $S$ is full in full in every weight space for which it is nonzero.
        # Such a set satisfies the weight diagram arrow conditions due to the
        # necessary conditions on $d_{\lambda}$. No need to check again
        yield identity_matrix(QQ, sum(f for _,_,f in dlist))[:,
                [i for wt,m,f in dlist if m == f for i in wtd.get_vertex(wt)]]
        return

    # Otherwise, we need parameters. Here we check all combinations of choices
    # of pivot columns in each grassmannian

    for nzsi,nzs in enumerate(product(*[combinations(range(f),m) for wt,m,f in dlist])):

        if verbose:
            print(nzsi,end=' ')
            sys.stdout.flush()

        nvars = sum( (nzi+1)*(j-i-1) for (wt,m,f),nz in zip(dlist,nzs)
            for nzi,(i,j) in enumerate(zip(nz,nz[1:]+(f,))))
        R = PolynomialRing(QQ,'t',nvars,implementation='singular') if nvars > 0 else QQ

        S = {}
        xi = 0
        for (wt,m,f),nz in zip(dlist,nzs):
            t = matrix(R,f,m,sparse=True)
            t[nz,:] = identity_matrix(R,m,sparse=True)
            for j,ks in enumerate(zip(nz,nz[1:]+(f,))):
                inc = (ks[1]-ks[0]-1)*(j+1)
                t[ks[0]+1:ks[1],:j+1] = matrix(R,ks[1]-ks[0]-1,j+1,R.gens()[xi:xi+inc])
                xi += inc 

            S[wt] = (t, nz) # remember the pivots for equations below

        # Now restrict the parameters appearing so that $S$ is closed under the
        # arrows of the weight diagram
        eqs = []
        for wta,wtb,x in wtd.edges():
            S1,_ = S[wta]
            S2,S2pvts = S[wtb]
            # Reduce the columns of xS1 modulo S2 using the pivots of S2.
            xS1 = (x*S1).T
            S2 = S2.T
            for i,j in enumerate(S2pvts):
                for k in xS1.nonzero_positions_in_column(j):
                    xS1[k] -= xS1[k,j]*S2[i]
            # xS1 now is in a normal form modulo S2, so the equations of
            # containment are the conditions that xS1 == 0
            eqs.extend(xS1.dict().values())

        I = R.ideal(eqs)
        if R.one() in I:
            continue
        Rbar = R.quo(I)

        Smat = block_diagonal_matrix([S[wt][0].apply_map(Rbar,sparse=True,R=Rbar) 
            for wt,_,_ in dlist])
        ix = [i for wt,_,_ in dlist for i in wtd.get_vertex(wt)]
        ixi = [None]*len(ix)
        for j,i in enumerate(ix):
            ixi[i] = j
        Smat = Smat[ixi,:]

        yield Smat

    if verbose: 
        print()

@
Given a weight diagram \code{wtd} and a target dimension \code{dim}, this
function computes the integer points $d_\lambda$ of the polytope corresponding
to the following necessary conditions that assignments $d_\lambda$ have
$Y_{d_\lambda}\ne \varnothing$ (and $\sum_\lambda d_\lambda = \code{dim}$):
\begin{enumerate}
\item \label{primal} Suppose that $M_\mu \to M_{\lambda_i}$ in the weight diagram, where
$\lambda_i$ ranges over some set of weights. The map 
$y : M_\mu \to \bigoplus_{i} M_{\lambda_i}$ 
satisfies 
$y (S_\mu) \subset \bigoplus_{i} S_{\lambda_i}$. 
In particular, 
$d_\mu \le \operatorname{dim} \operatorname{ker} y + \sum_{i}
d_{\lambda_i}$.

\item \label{dual} Dually, suppose that $M_{\mu_i} \to M_\lambda$ in the weight diagram, where
$\mu_i$ ranges over some set of weights. The map 
$z : M_\lambda^* \to \bigoplus_{i} M_{\mu_i}^*$ 
satisfies 
$z (S_\lambda^\perp) \subset \bigoplus_{i} S_{\mu_i}^\perp$. 
In particular, 
$\operatorname{dim}M_\lambda - d_\lambda \le \operatorname{dim}
\operatorname{ker} z + \sum_{i}
\operatorname{dim}(M_{\mu_i}) - d_{\mu_i}$.

\item \label{composition} One can apply the previous conditions to compositions of arrows in the
weight diagram. We use only the condition corresponding to a single 
arrow $w : M_\mu \to M_\nu \to M_\lambda$. For a single arrow, conditions (\ref{primal})
        and (\ref{dual}) are the same: $d_\mu \le
        \operatorname{ker}\operatorname{dim} w + d_\lambda$.
\end{enumerate}
<<complete=False>>=

def possible_dim_assignments(wtd,dim):
    lp = MixedIntegerLinearProgram()
    for wt in wtd:
        lp.set_min(lp[wt],0)
        lp.set_max(lp[wt],len(wtd.get_vertex(wt)))

    lp.add_constraint(lp.sum(lp[wt] for wt in wtd) == dim)

    for wt in wtd:
        # Condition $(\ref{primal})$
        for k in range(1,len(wtd.outgoing_edges(wt))+1):
            for es in combinations(wtd.outgoing_edges(wt),k):
                kdim = block_matrix([[xr] for _,_,xr in es]).right_kernel().dimension()
                lp.add_constraint(lp[wt] <= kdim + lp.sum(lp[wtr] for _,wtr,_ in es))

        # Condition $(\ref{dual})$
        # This when $k = 1$ occurs also for condition $(\ref{primal})$ as well, so we skip it.
        for k in range(2,len(wtd.incoming_edges(wt))+1):
            for es in combinations(wtd.incoming_edges(wt),k):
                cokdim = block_matrix([[-xr.transpose()] 
                    for _,_,xr in es]).right_kernel().dimension()
                lp.add_constraint(len(wtd.get_vertex(wt)) - lp[wt] <= cokdim + lp.sum(
                    len(wtd.get_vertex(wtl)) - lp[wtl] for wtl,_,xr in es))

    # Condition $(\ref{composition})$
    for wtstart in wtd:
        for _,wtmid,x1 in wtd.outgoing_edges(wtstart):
            for _,wtlast,x2 in wtd.outgoing_edges(wtmid):
                kdim = (x2*x1).right_kernel().dimension()
                lp.add_constraint(lp[wtstart] <= kdim + lp[wtlast])

    # We have computed the polytope, now enumerate the integer points

    # Fix an ordering of the weights $\lambda_i$
    wts = wtd.topological_sort()

    # Given assignments of $d_{\lambda_j}$, $j\le i-1$, set $d_{\lambda_i}$ to the values for which the 
    # polytope still intersects the coordinate hyperplane corresponding to the
    # current partial assignment and recursively apply this procedure.
    from sage.numerical.mip import MIPSolverException
    def dfs(i):
        if i == len(wts):
            # We have set all coordinates to integer values and remain in the
            # polytope, report this as a solution
            yield {wt : int(lp.get_min(lp[wt])) for wt in wts}
            return
        wt = wts[i]
        mult = int(lp.get_max(lp[wt]))
        for dcur in range(0, mult+1):
            lp.set_min(lp[wt],dcur)
            lp.set_max(lp[wt],dcur)
            try:
                # The polytope has nonzero intersection with set corresponding
                # to fixing the first $i$ coordinates as we have. Recursively try 
                # to set the remaining coordinates and report all solutions.
                lp.solve()
                for pt in dfs(i+1):
                    yield pt
            except MIPSolverException:
                # There are no points in the polytope with the first $i$
                # coordinates fixed to the values we have used. Don't search
                # further.
                pass
        lp.set_min(lp[wt],0)
        lp.set_max(lp[wt],mult)

    # print(len(list(dfs(0))))
    return dfs(0)

@
\subsection{$(210)$ and $(120)$ tests}
<<complete=False>>=

# takes a grassmannian candidate, represented as the column space of the matrix
# W, possibly with parameters, and performs the 210 and 120 tests. If no
# parameter value satisfies the test, None is returned, otherwise, W is returned
# in the quotient ring modulo the required equations on the parameters
def AB_grass_restrict_ok(W,adim,r):
    bdim = W.dimensions()[0] // adim
    M = matrix_11_to_21(W,adim)
    eqs = matrix_rank_le_eqs(M, M.dimensions()[0] - r)
    # if 1 in eqs or (M.base_ring() is not QQ and 1 in M.base_ring().ideal(eqs)): 
    if 1 in eqs:
        return None
    M = matrix_11_to_21(transpose_tensor(W,adim),bdim)
    eqs.extend(matrix_rank_le_eqs(M, M.dimensions()[0] - r))
    if 1 in eqs or (M.base_ring() is not QQ and 1 in M.base_ring().ideal(eqs)): 
        return None
    S = W.base_ring().quo(eqs)
    return W.change_ring(S)

# takes a set of vectors I in A \ot B (in the form of an ab x S matrix), and
# returns a matrix whose columns span A*I subset S^2(A) \ot B
def matrix_11_to_21(B,a):
    b = B.dimensions()[0] // a
    S = B.dimensions()[1]
    W = {}
    # i,k < a
    # j < b
    # s < S
    for I,s in B.nonzero_positions():
        i,j = I // b, I % b
        v = B[I,s]
        for k in range(a):
            mi,ma = min(i,k),max(i,k)
            ix = (( binomial(ma+1,2)+mi )*b+j,s*a+k)
            W[ix] = W.get(ix,0) + v
    W = matrix(B.base_ring(),binomial(a+1,2)*b,S*a,W)
    return W

# A is bc x S, B is ca x U, C is ab x V
def matrix_to_111(A,B,C):
    a = int(sqrt(B.dimensions()[0]*C.dimensions()[0]/A.dimensions()[0]))
    b = C.dimensions()[0] // a
    c = B.dimensions()[0] // a
    W = {}
    for i in range(a):
        for I,l in A.nonzero_positions():
            j,k = I // c, I % c
            W[((i*b+j)*c+k, i*A.dimensions()[1]+l)] = A[j*c+k,l]
    for j in range(b):
        for I,l in B.nonzero_positions():
            k,i = I // a, I % a
            W[((i*b+j)*c+k, a*A.dimensions()[1] + j*B.dimensions()[1]+l)] = B[k*a+i,l]
    for k in range(c):
        for I,l in C.nonzero_positions():
            i,j = I // b, I % b
            W[((i*b+j)*c+k, a*A.dimensions()[1] + b*B.dimensions()[1] +\
                    k*C.dimensions()[1]+l)] = C[i*b+j,l]
    W = matrix(A.base_ring(),a*b*c,a*A.dimensions()[1]+b*B.dimensions()[1]+c*C.dimensions()[1],W)
    return W

# given a set of vectors in A \ot B (in the form of an ab x S matrix), returns
# the same set in B \ot A (in the orm of a ba x S matrix)
def transpose_tensor(B,a):
    b = B.dimensions()[0] // a
    S = B.dimensions()[1]
    Bp = {}
    for I,k in B.nonzero_positions():
        i,j = I // b, I % b
        Bp[(j*a+i,k)] = B[I,k]
    return matrix(B.base_ring(),B.dimensions()[0],B.dimensions()[1],Bp)

@

\subsection{Representation manipulation}
Given $T\in A\ot B\ot C$ and the representations of $A$, $B$, and $C$, this
function computes the representation of $T(C^*)^\perp \subset A^*\ot B^*$ and
the matrix of the embedding of the distinguished weight bases of these modules.
Optionally, the parameter \code{missing} may be set to $0$ to instead compute
this information for $T(A^*)^\perp \subset B^*\ot C^*$ or to $1$ to do this for  
$T(B^*)^\perp \subset C^*\ot A^*$.
<<complete=False>>=
def Tperp_rep_and_embedding(T,reps,missing=2):
    reps = reps[missing+1:] + reps[:missing]
    repAB = module_product(*[module_dual(rep) for rep in reps])

    Tcycl = T
    for i in range(missing):
        Tcycl = tensor_cycl(Tcycl)
    Tflattening = matrix(QQ,[m.list() for m in Tcycl],sparse=True)
    em = Tflattening.right_kernel_matrix().transpose().sparse_matrix()

    reptp = submodule_from_basis(repAB,em)
    return reptp,em

@
When \code{repa} and \code{repb} describe the representations of $V$, and $W$,
respectively this function computes description of the representation of $V\ot
W$. The distinguished weight basis of the tensor product is $v_i \ot w_j$
ordered lexicographically, where $w_i$ and $w_j$ are the distinguished weight
bases of $V$ and $W$, respectively. 
<<complete=False>>=
def module_product(repa,repb):
    wtsa, xsa = repa
    wtsb, xsb = repb
    wtsab = [wta + wtb for wta,wtb in product(wtsa,wtsb)]
    xsab = []
    for xa,xb in zip(xsa,xsb):
        xab = xa.tensor_product(identity_matrix(QQ,xb.nrows()))
        xab += identity_matrix(QQ,xa.nrows()).tensor_product(xb)
        xsab.append(xab)
    return (wtsab,xsab)

@
When \code{rep} describe the representation of $V$,
this function computes the description of the representation $V^*$.
The distinguished weight basis of $V^*$ is the dual basis of that of $V$.
<<complete=False>>=
def module_dual(rep):
    wts, xs = rep
    wtsd = [-wt for wt in wts]
    xsd = [-x.transpose() for x in xs]
    return (wtsd,xsd)

@
Here, \code{rep} describes the representation of $V$, and \code{em} is an $\vvv \times
\www$ matrix containing as columns a weight basis of a submodule $W$ of $V$,
e.g., it is the matrix of the embedding $W\to V$.
This function computes the description of the representation $W$ with respect to
this basis. The facts that $B$ describes a weight basis and that $W$ is a
$\BB$-submodule of $V$ are checked.
<<complete=False>>=
def submodule_from_basis(rep,em):
    wts, xs = rep

    # check em describes a basis
    assert em.rank() == em.ncols()

    wtsw = []
    # check the columns of em are weight vectors and find their weights
    for v in em.columns():
        wt = wts[v.nonzero_positions()[0]]
        assert all(wt == wts[j] for j in v.nonzero_positions())
        wtsw.append(wt)

    xsw = []
    # check $W$ is fixed under the simple root vectors and compute the matrix of
    # their action
    for x in xs:
        # find y solving x*em == em*y, and raises an error if there is none
        y = em.solve_right(x*em) 
        # Since em is basis, the eqution x*em == em*y is sufficient to
        # guarantee the claims
        xsw.append(y)

    return (wtsw,xsw)

# # B: n x k matrix
# # C: m x l matrix
# # m: m x n matrix mapping the column space of B to the column space of C
# # returns the l x k matrix representing m in the bases B and C
# def restrict_map(m,C,B):
#     I = C.pivot_rows()
#     return C[I,:].solve_right((m*B)[I,:])

# a : a representation of L
# C : the cartan matrix of the semisimple part of L
#
# computes a dictionary summarizing info of this representation. In particular,
# the keys of the returned dictionary are
# 'M': a dictionary mapping weights to a distinguished basis of the corresponding weight space
# 'C': The Cartan matrix of L
# 'a': the representation
# 'tot': a distinguished total ordering of the weights compatible with P; for
#     convenience weights are given along with the multiplicity of the weight space
# 'wtg': directed graph with a vertex for each weight and an edge for each
#     raising operator. The edges are labelled with the raising operator between the
#     corresponding weight spaces in the distinguished bases of those spaces
# 
def weight_diagram(rep,simple_roots):
    # tot = simultaneous_eigenspace(a[2])
    wts, xs = rep
    dim = len(wts)

    assert all(x.nrows() == dim and x.ncols() == dim for x in xs)

    wtd = DiGraph()
    for bi,wt in enumerate(wts):
        wt.set_immutable()
        if wt not in wtd:
            wtd.add_vertex(wt)
            wtd.set_vertex(wt,[])
        wtd.get_vertex(wt).append(bi)

    for wt in wtd:
        wt.set_immutable()
        for root,x in zip(simple_roots,xs):
            wt_raised = immut(wt + root)
            wt_raised.set_immutable()
            if wt_raised in wtd:
                wtd.add_edge(wt,wt_raised,
                        x[wtd.get_vertex(wt_raised),wtd.get_vertex(wt)])
    
    return wtd

@
\subsection{Equations for matrices of rank $\le r$}
<<complete=False>>=

# M : matrix
# r : natural number 
#
# computes generators of the ideal of r+1 by r+1 minors of M
def matrix_rank_le_eqs(M,r):
    if M.base_ring() is QQ:
        return [1] if M.rank() > r else []
    else:
        try:
            I = M.base_ring().defining_ideal()
            M = M.apply_map(lambda e: e.lift())
            return list(minors_ideal(M,r+1,I).basis)
        except AttributeError:

            return list(minors_ideal(M,r+1).basis)


# M : matrix with base ring a polynomial ring over QQ or a quotient of such by an ideal
# nminors: a parameter determining when to revert to the base case in the
#    recursive algorithm. Output should be independent of its value, but
#    performance may be tuned
#
# returns the radical of the ideal of r by r minors of m
def minors_ideal(m,r,I=None):
    from collections import Counter

    S = m.base_ring()
    if I is None: I = S.ideal()

    R = PolynomialRing(S.base_ring(),S.gens()+('d',))
    dv = R.gens()[-1]

    def rec(m,I,d,r):
        if m.is_zero():
            yield I
            return
        if r == 1:
            yield I + m.coefficients()
            return

        f = Counter(m.dict().values()).most_common(1)[0][0]

        # pass to the open set where f not identically zero, e.g., localize at f
        mcur = m.subs({dv : dv*f})
        Icur = I.elimination_ideal(dv) + [dv*d*f-1]
        mcur,lo = sparse_elimination_by_units(mcur,Icur)
        if lo < r:
            for Iout in rec(mcur[lo:,lo:],Icur,d*f,r-lo):
                yield Iout

        # pass to the closed set where f == 0
        Icur = I + f
        mcur,lo = sparse_elimination_by_units(m,Icur)
        if lo < r:
            for Iout in rec(mcur[lo:,lo:],Icur,d,r-lo):
                yield Iout

    return S.ideal(1).intersection(*(I.elimination_ideal(dv).change_ring(S)
            for I in rec(m.change_ring(R), I.change_ring(R), R.one(), r)))
    return rec(m.change_ring(R), I.change_ring(R), R.one(), r)

# m : matrix
# 
# row reduces m as far as possible pivoting using unit entries. Column swaps are
# also performed. m is modified in place and the number of pivots r is returned. 
# After this operation, m has the form
# [ T A ]
# [ 0 B ]
# where T is r by r and  upper triangular with units along the diagonal, B 
# contains no units
from sage.libs.singular.function import singular_function
lift = singular_function('lift')
def sparse_elimination_by_units(m,I):
    m = m.apply_map(lambda e: I.reduce(e))

    def try_inverse(e):
        try:
            return lift(I+e,1).list()[-1]
        except RuntimeError:
            return None

    r = 0
    while True:
        if r == min(m.nrows(),m.ncols()):
            break

        einv = None
        for (i,j),e in m[r:,r:].dict().items():
            einv = try_inverse(e)
            if einv is not None:
                break
        if einv is None:
            break
        i += r
        j += r

        m.swap_rows(r,i)
        m.swap_columns(r,j)
        m[r,:] *= einv
        for k in m.nonzero_positions_in_row(r):
            m[r,k] = I.reduce(m[r,k])
        assert m[r,r] == 1
        for i in m.column(r)[r+1:].nonzero_positions():
            i += r+1
            m.add_multiple_of_row(i,r,-m[i,r])
            for k in m.nonzero_positions_in_row(i):
                m[i,k] = I.reduce(m[i,k])
        r += 1

    return m,r
  


@
\subsection{Miscellaneous}
<<complete=False>>=

# T : tensor in A ot B ot C
#
# returns T permuted to lie in B ot C ot A
def tensor_cycl(T):
    m = len(T)
    n,s = T[0].dimensions()
    S = [zero_matrix(QQ,s,m) for i in range(n)]
    for i,j,k in product(range(m),range(n),range(s)):
        S[j][k,i] = T[i][j,k]
    return S

def immut(obj):
    obj.set_immutable()
    return obj

@


\end{document}
